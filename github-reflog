#!/usr/bin/env python

from __future__ import print_function
import sys
import os
import subprocess
import requests
import getpass
import textwrap
import time
from colorama import init, Fore, Style

import argparse
parser = argparse.ArgumentParser()
parser.add_argument("--naughty",
        help="Ignore Github's requested poll-interval (naughty naughty)",
        action="store_true")
args = parser.parse_args()

try:
    # Win32
    from msvcrt import getch
except ImportError:
    # UNIX
    def getch():
        import tty, termios
        fd = sys.stdin.fileno()
        old = termios.tcgetattr(fd)
        try:
            tty.setraw(fd)
            return sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old)

init()

# Initialize the pager stuff. Note, this will probably only work on *nixes
MAX_PAGE_LINES = int(os.environ.get('LINES', 30))
CURRENT_LINE = 0
PAGE_TEXT = Style.BRIGHT + \
    "Press any key to continue, Q to quit...\r" + Style.NORMAL
CLEAR_TEXT = ' ' * len(PAGE_TEXT) + "\r"

try:
    username = subprocess.check_output(['git', 'config', 'github.username'])
    username = username.strip()
except subprocess.CalledProcessError:
    print("No Github username found!")
    print("Please set with:")
    print("\tgit config github.username <username>")
    sys.exit(1)

try:
    repouser = subprocess.check_output(['git', 'config', 'github.repouser'])
    repouser = repouser.strip()
except subprocess.CalledProcessError:
    print("No Github repo username found!")
    print("Please set with:")
    print("\tgit config github.repouser <repo username>")
    sys.exit(1)

try:
    reponame = subprocess.check_output(['git', 'config', 'github.reponame'])
    reponame = reponame.strip()
except subprocess.CalledProcessError:
    print("No Github repo name found!")
    print("Please set with:")
    print("\tgit config github.reponame <repo name>")
    sys.exit(1)

password = getpass.getpass("Please enter password: ")

# Type conversion for Python3
if isinstance(username, bytes):
    username = username.decode('utf-8')
if isinstance(repouser, bytes):
    repouser = repouser.decode('utf-8')
if isinstance(reponame, bytes):
    reponame = reponame.decode('utf-8')

def pager(line=""):
    global CURRENT_LINE
    global MAX_PAGE_LINES
    global PAGE_TEXT
    global CLEAR_TEXT
    if CURRENT_LINE > MAX_PAGE_LINES - 3:
        print(PAGE_TEXT, end="")
        c = getch()
        print(CLEAR_TEXT, end="")
        CURRENT_LINE = 0
        if c == 'q' or c == 'Q' or ord(c) == 3:
            sys.exit(0)

    print(line)
    CURRENT_LINE = CURRENT_LINE + 1

def pager_message(message):
    pretty_message = textwrap.wrap(message)
    for l in pretty_message:
        if isinstance(l, str):
            pager('   ' + l)
        else:
            pager(u'   ' + l.decode())

def parse_event(event):
    event_id = event['id']
    event_type = event['type']
    event_user = event['actor']['login']
    event_userurl = event['actor']['url']
    event_timestamp = event['created_at']

    # Header
    pager(u'' + Fore.YELLOW + event_id + u' ' + event_type + Fore.RESET)
    pager('User:    {0} <{1}>'.format(event_user, event_userurl))
    pager('Date:    {0}'.format(event_timestamp))

    if event_type == 'PullRequestEvent':
        pr = event['payload']['number']
        pr_url = event['payload']['pull_request']['html_url']
        action = event['payload']['action']
        state = event['payload']['pull_request']['state']
        created = event['payload']['pull_request']['created_at']
        updated = event['payload']['pull_request']['updated_at']
        pr_user = event['payload']['pull_request']['user']['login']
        pr_userurl = event['payload']['pull_request']['user']['html_url']
        head_sha = event['payload']['pull_request']['head']['sha']
        head_ref = event['payload']['pull_request']['head']['ref']
        title = event['payload']['pull_request']['title']
        body = event['payload']['pull_request']['body']
        pager(u"PR:      #{0} <{1}>".format(pr, pr_url))
        pager(u"Created: {0}\tUpdated: {1}".format(created, updated))
        pager(u"SHA:     {0}".format(head_sha))
        pager(u"Author:  {0} <{1}>".format(pr_user, pr_userurl))
        pager(u"Ref:     {0}".format(head_ref))
        pager(u"Action:  " + Fore.BLUE + Style.BRIGHT + action + Fore.RESET + \
                Style.NORMAL + "\t\t\tState: " + Fore.BLUE + Style.BRIGHT + \
                state + Fore.RESET + Style.NORMAL)
        if action == 'closed':
            merged = event['payload']['pull_request']['merged']
            if merged:
                pager(u"Merged:  " + Fore.GREEN + Style.BRIGHT + "True" + \
                        Fore.RESET + Style.NORMAL)
            else:
                pager(u"Merged:  " + Fore.RED + Style.BRIGHT + "False" + \
                        Fore.RESET + Style.NORMAL + " (unmerged commits)")

        pager()
        pager(" " + Style.BRIGHT + title + Style.NORMAL)
        pager()
        pager_message(body)
        pager()

    elif event_type == 'PushEvent':
        head_sha = event['payload']['head']
        ref = event['payload']['ref']
        # Find the associated message for HEAD
        message = 'Unknown'
        author = 'Unknown'
        email = 'Unknown'
        for commit in event['payload']['commits']:
            if commit['sha'] == head_sha:
                message = commit['message']
                author = commit['author']['name']
                email = commit['author']['email']

        pager(u"SHA:     {0}".format(head_sha))
        pager(u"Author:  {0} <{1}>".format(author, email))
        pager(u"Ref:     {0}".format(ref))
        pager()

        pager_message(message)
        pager()

    else:
        # Catch-all for everything else
        pager(u"{0} {1} {2}".format(event_id, event_type, event_user))
        pager()

def parse_requests(req):
    events = req.json()
    for e in events:
        parse_event(e)

url = "https://api.github.com/repos/{0}/{1}/events".format(
        repouser, reponame)

r = requests.get(url, auth=(username, password))

action_time = time.clock()

poll_interval = float(r.headers['x-poll-interval'])

next_url = None
if 'next' in r:
    next_url = r.links['next']

more = True

while more:
    parse_requests(r)
    if next_url is not None:
        post_action_time = time.clock()
        if not args.naughty:
            if post_action_time - action_time < poll_interval:
                wait_time = poll_interval - (post_action_time - action_time)
                print("\nSleeping for {0} seconds...\n".format(wait_time))
                time.sleep(float(wait_time))

        r = requests.get(next_url, auth=(username, password))
        poll_interval = r.headers['x-poll-interval']

        next_url = None
        if r.links.has_key('next'):
            next_url = r.links['next']
    else:
        more = False

