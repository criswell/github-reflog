#!/usr/bin/env python

from __future__ import print_function
import sys
import os
import subprocess
import requests
import getpass
import textwrap
import time
from colorama import init, Fore, Back, Style

try:
    # Win32
    from msvcrt import getch
except ImportError:
    # UNIX
    def getch():
        import sys, tty, termios
        fd = sys.stdin.fileno()
        old = termios.tcgetattr(fd)
        try:
            tty.setraw(fd)
            return sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old)

init()

# Initialize the pager stuff. Note, this will probably only work on *nixes
MAX_PAGE_LINES = os.environ.get('LINES', 30)
CURRENT_LINE = 0
PAGE_TEXT = Style.BRIGHT + "Press any key to continue, Q to quit...\r" + Style.NORMAL
CLEAR_TEXT = ' ' * len(PAGE_TEXT) + "\r"

try:
    username = subprocess.check_output(['git', 'config', 'github.username'])
    username = username.strip()
except subprocess.CalledProcessError:
    pager("No Github username found!")
    pager("Please set with:")
    pager("\tgit config github.username <username>")
    sys.exit(1)

try:
    repouser = subprocess.check_output(['git', 'config', 'github.repouser'])
    repouser = repouser.strip()
except subprocess.CalledProcessError:
    pager("No Github repo username found!")
    pager("Please set with:")
    pager("\tgit config github.repouser <repo username>")
    sys.exit(1)

try:
    reponame = subprocess.check_output(['git', 'config', 'github.reponame'])
    reponame = reponame.strip()
except subprocess.CalledProcessError:
    pager("No Github repo name found!")
    pager("Please set with:")
    pager("\tgit config github.reponame <repo name>")
    sys.exit(1)

password = getpass.getpass("Please enter password: ")

def pager(line=""):
    global CURRENT_LINE
    global MAX_PAGE_LINES
    global PAGE_TEXT
    global CLEAR_TEXT
    if CURRENT_LINE > MAX_PAGE_LINES - 3:
        print(PAGE_TEXT, end="")
        c = getch()
        print(CLEAR_TEXT, end="")
        CURRENT_LINE = 0
        if c == 'q' or c == 'Q' or ord(c) == 3:
            sys.exit(0)

    print(line)
    CURRENT_LINE = CURRENT_LINE + 1

def pager_message(message):
    pretty_message = textwrap.wrap(message)
    for l in pretty_message:
        pager(u'   ' + l.decode())

def parse_event(event):
    event_id = event['id']
    event_type = event['type']
    event_user = event['actor']['login']
    event_userurl = event['actor']['url']
    event_timestamp = event['created_at']

    # Header
    header = u'' + Fore.YELLOW + event_id + u' ' + event_type + Fore.RESET + \
            '\nUser:    {0} <{1}>'.format(event_user, event_userurl) + \
            '\nDate:    {0}'.format(event_timestamp)
    pager(header)

    if event_type == 'PullRequestEvent':
        pr = event['payload']['number']
        pr_url = event['payload']['pull_request']['html_url']
        action = event['payload']['action']
        state = event['payload']['pull_request']['state']
        created = event['payload']['pull_request']['created_at']
        updated = event['payload']['pull_request']['updated_at']
        pr_user = event['payload']['pull_request']['user']['login']
        pr_userurl = event['payload']['pull_request']['user']['html_url']
        head_sha = event['payload']['pull_request']['head']['sha']
        head_ref = event['payload']['pull_request']['head']['ref']
        title = event['payload']['pull_request']['title']
        body = event['payload']['pull_request']['body']
        pager(u"PR:      #{0} <{1}>".format(pr, pr_url))
        pager(u"Created: {0}\tUpdated: {1}".format(created, updated))
        pager(u"SHA:     {0}".format(head_sha))
        pager(u"Author:  {0} <{1}>".format(pr_user, pr_userurl))
        pager(u"Ref:     {0}".format(head_ref))
        pager(u"Action:  " + Fore.BLUE + Style.BRIGHT + action + Fore.RESET + \
                Style.NORMAL + "\t\t\tState: " + Fore.BLUE + Style.BRIGHT + \
                state + Fore.RESET + Style.NORMAL)
        if action == 'closed':
            merged = event['payload']['pull_request']['merged']
            if merged:
                pager(u"Merged:  " + Fore.GREEN + Style.BRIGHT + "True" + \
                        Fore.RESET + Style.NORMAL)
            else:
                pager(u"Merged:  " + Fore.RED + Style.BRIGHT + "False" + \
                        Fore.RESET + Style.NORMAL + " (unmerged commits)")

        pager("\n " + Style.BRIGHT + title + Style.NORMAL + "\n")
        pager_message(body)
        pager()

    elif event_type == 'PushEvent':
        head_sha = event['payload']['head']
        ref = event['payload']['ref']
        # Find the associated message for HEAD
        message = 'Unknown'
        author = 'Unknown'
        email = 'Unknown'
        for commit in event['payload']['commits']:
            if commit['sha'] == head_sha:
                message = commit['message']
                author = commit['author']['name']
                email = commit['author']['email']

        pager(u"SHA:     {0}".format(head_sha) +
              u"\nAuthor:  {0} <{1}>".format(author, email) +
              u"\nRef:     {0}\n".format(ref))

        pager_message(message)
        pager()

    else:
        # Catch-all for everything else
        pager(u"{0} {1} {2}\n".format(event_id, event_type, event_user))

def parse_requests(r):
    events = r.json()
    for e in events:
        parse_event(e)

url = "https://api.github.com/repos/{0}/{1}/events".format(repouser, reponame)

r = requests.get(url, auth=(username, password))

poll_interval = r.headers['x-poll-interval']

next_url = None
if r.links.has_key('next'):
    next_url = r.links['next']

while next_url is not None:
    parse_requests(r)
    print("\nSleeping for {0} seconds...\n".format(poll_interval))
    time.sleep(float(poll_interval))
    r = requests.get(url, auth=(username, password))
    poll_interval = r.headers['x-poll-interval']

    next_url = None
    if r.links.has_key('next'):
        next_url = r.links['next']

